#
# Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

ID_MUST_BE_STRING = A propriedade "{0}" tem uma anota\u00E7\u00E3o XmlID, mas seu tipo n\u00E3o \u00E9 String.

# {0} - field or field accessor (getter/setter) e.g.: foo.Bar#field has mutually exclusive annotations @javax.xml.bind.annotation.XmlAttribute and @javax.xml.bind.annotation.XmlElement OR foo.Bar#getField() has mutually exclusive annotations @javax.xml.bind.annotation.XmlAttribute and @javax.xml.bind.annotation.XmlElement
MUTUALLY_EXCLUSIVE_ANNOTATIONS = {0} tem anota\u00E7\u00F5es mutuamente exclusivas @{1} e @{2}

DUPLICATE_ANNOTATIONS = anota\u00E7\u00E3o @{0} encontrada em dois locais; um \u00E9 suficiente.

# {0} - class name. e.g.: java.lang.StackTraceElement does not have a no-arg default constructor.
NO_DEFAULT_CONSTRUCTOR = {0} n\u00E3o tem um construtor no-arg default.

CANT_HANDLE_INTERFACE = {0} \u00E9 uma interface e JAXB n\u00E3o pode tratar interfaces.

CANT_HANDLE_INNER_CLASS = {0} \u00E9 uma classe interna n\u00E3o est\u00E1tica e JAXB n\u00E3o pode trat\u00E1-la.

ANNOTATION_ON_WRONG_METHOD = A anota\u00E7\u00E3o JAXB foi colocada em um m\u00E9todo que n\u00E3o \u00E9 uma propriedade JAXB

GETTER_SETTER_INCOMPATIBLE_TYPE = O tipo de getter \u00E9 {0}, mas o do setter \u00E9 {1}. Eles devem ser iguais.

DUPLICATE_ENTRY_IN_PROP_ORDER = A propriedade "{0}" aparece mais de uma vez em @XmlType.propOrder

DUPLICATE_PROPERTIES = H\u00E1 duas propriedades com o nome "{0}"

XML_ELEMENT_MAPPING_ON_NON_IXMLELEMENT_METHOD = O m\u00E9todo {0} tem @XmlElementMapping nele, mas ele n\u00E3o retorna um subtipo de JAXBElement.

# {0} - (xsd) type name. e.g. ns:MyType is not bound to a complex type, and therefore illegal as the scope.
SCOPE_IS_NOT_COMPLEXTYPE = {0} n\u00E3o est\u00E1 associado a um tipo complexo e, portanto, o escopo \u00E9 inv\u00E1lido.

CONFLICTING_XML_ELEMENT_MAPPING = O nome do elemento "{{0}}"{1} tem mais de um mapeamento.

REFERENCE_TO_NON_ELEMENT = A propriedade {0} foi anotada com @XmlReference, mas n\u00E3o se refere a um elemento.

NON_EXISTENT_ELEMENT_MAPPING = N\u00E3o existe mapeamento de elemento para "{0}":"{1}"

TWO_ATTRIBUTE_WILDCARDS = {0} tem duas propriedades com a anota\u00E7\u00E3o @XmlAnyAttribute.

SUPER_CLASS_HAS_WILDCARD = N\u00E3o pode ter @XmlAnyAttribute quando uma classe-base j\u00E1 a possui.

INVALID_ATTRIBUTE_WILDCARD_TYPE = @XmlAnyAttribute \u00E9 colocado em uma propriedade cujo tipo \u00E9 {0}, mas ele precisa ser atribu\u00EDdo a java.util.Map.

PROPERTY_MISSING_FROM_ORDER = A propriedade {0} est\u00E1 presente, mas n\u00E3o foi especificada em @XmlType.propOrder

PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY = A propriedade {0} aparece na @XmlType.propOrder, mas essa propriedade n\u00E3o existe. Voc\u00EA quis dizer {1}?

# {1} - (local) type name e.g.: '#foo' is not a valid value for 'NCName'
INVALID_XML_ENUM_VALUE = "{0}" n\u00E3o \u00E9 um valor v\u00E1lido para {1}.

FAILED_TO_INITIALE_DATATYPE_FACTORY = Falha ao inicializar a classe DatatypeFactory de JAXP 1.3.

NO_IMAGE_WRITER = Nenhum javax.imageio.ImageWriter dispon\u00EDvel para o tipo MIME "{0}" especificado

ILLEGAL_MIME_TYPE = "{0}" n\u00E3o \u00E9 um tipo MIME v\u00E1lido: {1}

ILLEGAL_ANNOTATION = a anota\u00E7\u00E3o {0} n\u00E3o pode ser colocada aqui

MULTIPLE_VALUE_PROPERTY = S\u00F3 \u00E9 permitido um @XmlValue por classe, mas duas propriedades foram anotadas com @XmlValue.

XMLVALUE_IN_DERIVED_TYPE = @XmlValue n\u00E3o \u00E9 permitido em uma classe que deriva outra classe.

ELEMENT_AND_VALUE_PROPERTY = Se uma classe tiver a propriedade @XmlElement, ela n\u00E3o poder\u00E1 ter a propriedade @XmlValue.

CONFLICTING_XML_TYPE_MAPPING = Duas classes t\u00EAm o mesmo nome do tipo XML "{0}". Use @XmlType.name e @XmlType.namespace para atribuir outros nomes a elas.

SIMPLE_TYPE_IS_REQUIRED = @XmlAttribute/@XmlValue precisa fazer refer\u00EAncia a um tipo Java que \u00E9 mapeado ao texto em XML.

PROPERTY_COLLISION = A classe tem duas propriedades do mesmo nome "{0}"

INVALID_IDREF = A propriedade XmlIDREF est\u00E1 fazendo refer\u00EAncia a um tipo "{0}" que n\u00E3o tem uma propriedade XmlID.

INVALID_XML_ELEMENT_REF = @XmlElementRef Inv\u00E1lido: o tipo "{0}" ou qualquer uma de suas subclasses n\u00E3o \u00E9 conhecida neste contexto.

NO_XML_ELEMENT_DECL = N\u00E3o h\u00E1 ObjectFactory com um @XmlElementDecl para o elemento "{{0}}"{1}.

XML_ELEMENT_WRAPPER_ON_NON_COLLECTION = @XmlElementWrapper s\u00F3 \u00E9 permitido em uma propriedade de coleta, mas "{0}" n\u00E3o \u00E9 uma propriedade de coleta.

ANNOTATION_NOT_ALLOWED = a anota\u00E7\u00E3o {0} n\u00E3o \u00E9 permitida neste tipo de propriedade.

XMLLIST_NEEDS_SIMPLETYPE = {0} \u00E9 mapeado para um fragmento XML estruturado (tipo complexo AKA) e, portanto, \u00E9 incompat\u00EDvel com @XmlList.

XMLLIST_ON_SINGLE_PROPERTY = @XmlList n\u00E3o pode ser colocado em uma propriedade de valor \u00FAnico

NO_FACTORY_METHOD = A classe de factory "{0}" n\u00E3o tem o m\u00E9todo de factory de argumentos zero est\u00E1ticos "{1}".

FACTORY_CLASS_NEEDS_FACTORY_METHOD = XmlType n\u00E3o definiu um m\u00E9todo de factory para a classe de Factory "{0}".

MISSING_JAXB_PROPERTIES = O pacote "{0}" n\u00E3o encontrou o arquivo jaxb.properties. Voc\u00EA copiou este arquivo do diret\u00F3rio de origem gerado ou incluiu-o no classpath?

TRANSIENT_FIELD_NOT_BINDABLE = O campo transiente "{0}" n\u00E3o pode ter uma anota\u00E7\u00E3o JAXB.

THERE_MUST_BE_VALUE_IN_XMLVALUE = O objeto deve ter algum valor no campo @XmlValue: {0}

INCOMPATIBLE_API_VERSION = O jar da API do JAXB 2.1 est\u00E1 sendo carregado (de {0}), mas este RI (de {1}) requer o jar da API do JAXB 2.2.

# {0}, {1} - absolute class location e.g. JAXB 2.1 API is being loaded from the bootstrap classloader, but this RI (from jar:file:/c:/foo/bar/jaxb-impl.jar!/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.class) needs 2.2 API.
INCOMPATIBLE_API_VERSION_MUSTANG = A API do JAXB 2.1 est\u00E1 sendo carregada do carregador de classes de bootstrap, mas este RI (de {1}) precisa da API 2.2. Use o mecanismo do diret\u00F3rio endossado para colocar jaxb-api.jar no carregador de classes de bootstrap. (Consulte http://java.sun.com/j2se/1.6.0/docs/guide/standards/)

# {0}, {1} - absolute class location e.g. JAXB 2.1 API is being loaded from the bootstrap classloader, but this RI (from jar:file:/c:/foo/bar/jaxb-impl.jar!/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.class) needs 2.2 API.
RUNNING_WITH_1_0_RUNTIME = Voc\u00EA est\u00E1 tentando executar o runtime do JAXB 2.0 (de {1}) mas voc\u00EA tem o runtime do JAXB 1.0 antigo no classpath (em {0}). Remova o runtime do JAXB 1.0 do runtime do 2.0 para funcionar corretamente.

UNMATCHABLE_ADAPTER = O adaptador {0} n\u00E3o \u00E9 aplic\u00E1vel ao tipo de campo {1}.

# {0} - com.sun.xml.internal.bind.XmlAccessorFactory, {1} - class name
ACCESSORFACTORY_INSTANTIATION_EXCEPTION = N\u00E3o \u00E9 poss\u00EDvel criar a inst\u00E2ncia de AccessorFactory {0} para a classe {1}.

# {0} - com.sun.xml.internal.bind.XmlAccessorFactory, {1} - class name
ACCESSORFACTORY_ACCESS_EXCEPTION = N\u00E3o \u00E9 poss\u00EDvel acessar a inst\u00E2ncia de AccessorFactory {0} para a classe {1}.

CUSTOM_ACCESSORFACTORY_PROPERTY_ERROR = A AccessorFactory {0} personalizada est\u00E1 reportando um erro ao acessar a propriedade. {1}

CUSTOM_ACCESSORFACTORY_FIELD_ERROR = A AccessorFactory {0} personalizada est\u00E1 reportando um erro ao acessar um campo. {1}

ANONYMOUS_ARRAY_ITEM = {0} foi usado como um tipo de componente do array; portanto, n\u00E3o pode ser an\u00F4nimo.

XMLGREGORIANCALENDAR_INVALID = Conjunto inv\u00E1lido de campos definido para o tipo XMLGregorianCalendar {0}.

XMLGREGORIANCALENDAR_SEC = Segundos n\u00E3o definidos.

XMLGREGORIANCALENDAR_MIN = Minutos n\u00E3o definidos.

XMLGREGORIANCALENDAR_HR = Hora n\u00E3o definida.

XMLGREGORIANCALENDAR_DAY = Dia n\u00E3o definido.

XMLGREGORIANCALENDAR_MONTH = M\u00EAs n\u00E3o definido.

XMLGREGORIANCALENDAR_YEAR = Ano n\u00E3o definido.

XMLGREGORIANCALENDAR_TIMEZONE = Fuso hor\u00E1rio n\u00E3o definido.
