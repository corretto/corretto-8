/*
* Copyright (c) 2018, 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
*
* This code is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License version 2 only, as
* published by the Free Software Foundation. Amazon designates this
* particular file as subject to the "Classpath" exception as provided
* by Oracle in the LICENSE file that accompanied this code.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* version 2 for more details (a copy is included in the LICENSE file that
* accompanied this code).
*
* You should have received a copy of the GNU General Public License version
* 2 along with this work; if not, write to the Free Software Foundation,
* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
*/

dependencies {
    compile project(path: ':openjdksrc', configuration: 'archives')
}
ext {
    // all linux distros and macos support 'uname -m'
    arch = ['uname', '-m'].execute().text.trim()

    switch (arch) {
        case 'x86_64':
            arch_alias = 'x64'
            break;
        case 'aarch64':
            arch_alias = arch
            break;
        default:
            throw new GradleException("${arch} is not suported")
    }
}

def jdkResultingImage = "$buildRoot/build/linux-${arch}-normal-server-release/images/j2sdk-image"
def binaryResultName = "amazon-corretto-${project.version.full}-alpine-linux-${arch_alias}"
def archiveName = "amazon-corretto-${project.version.full}-alpine-linux-${arch_alias}.tar.gz"
def debugArchiveName = "amazon-corretto-debugsymbols-${project.version.full}-alpine-linux-${arch_alias}.tar.gz"

/**
 * Create a local copy of the source tree in our
 * build root -- this is required since OpenJDK's
 * build wants to occur inside the source tree,
 * and we don't want to tamper with someone
 * else's tree.
 */
task copySource(type: Copy) {
    dependsOn project.configurations.compile
    from tarTree(project.configurations.compile.singleFile)
    into buildRoot
}

/**
 * Scan the patches folder for any .patch that needs
 * to be applied before start building.
 */
task applyPatches() {
    dependsOn copySource
    doLast {
        fileTree('patches').matching {
            include '*.patch'
        }.each { f ->
            ant.patch(patchfile: f, dir: "$buildRoot", strip: 1)
        }
    }
}

task configureBuild(type: Exec) {
    dependsOn applyPatches
    workingDir "$buildRoot"

    def milestone = project.findProperty("corretto.milestone") ?: "fcs"
    environment("LD_LIBRARY_PATH","")
    def configureCmd = [
        'bash',
        'configure',
        'LIBCXX=-static-libstdc++ -static-libgcc'
    ]
    configureCmd += correttoCommonFlags

    commandLine configureCmd
}

task executeBuild(type: Exec) {
    dependsOn configureBuild
    workingDir "$buildRoot"
    environment("LD_LIBRARY_PATH","")
    commandLine 'make','images'
    outputs.dir jdkResultingImage
}

task importAmazonCacerts(type: Exec) {
    dependsOn executeBuild
    workingDir jdkResultingImage
    // Default password for JSSE key store
    def keystore_password = "changeit"
    environment("LD_LIBRARY_PATH","")
    commandLine 'bin/keytool', '-importkeystore', '-noprompt',
                '-srckeystore', "${buildRoot}/amazon-cacerts",
                '-srcstorepass', keystore_password,
                '-destkeystore', 'jre/lib/security/cacerts',
                '-deststorepass', keystore_password
}

task copyBuildResults() {
    description 'Copy the JDK image and puts the results in build/.'
    dependsOn executeBuild
    dependsOn importAmazonCacerts

    doLast {
        def destination = "${buildDir}/${binaryResultName}"
        copy {
            from(buildRoot) {
                include 'ASSEMBLY_EXCEPTION'
                include 'LICENSE'
                include 'THIRD_PARTY_README'
                include 'commitId.txt'
                include 'version.txt'
            }
            into destination
        }
        exec {
            workingDir jdkResultingImage
            commandLine 'cp', '-Rf', '--parents', 'bin', 'include', 'jre', 'lib', 'man/man1', 'src.zip', destination
        }
    }
}

task packageDebugSymbols(type: Exec) {
    description 'Package the JDK debug symbols and puts the results in build/distributions.'
    dependsOn copyBuildResults
    String tarFile = "${distributionDir}/${debugArchiveName}"
    outputs.file tarFile
    workingDir buildDir
    commandLine 'bash', '-c',
        "tar -czf ${tarFile} \$(find ${binaryResultName} -name \"*.diz\")"
}

task packageBuildResults(type: Exec) {
    description 'Package the JDK image and puts the results in build/distributions.'
    dependsOn packageDebugSymbols
    String tarFile = "${distributionDir}/${archiveName}"
    outputs.file tarFile
    workingDir buildDir
    commandLine 'bash', '-c',
        "tar --exclude=*.diz -czf ${tarFile} ${binaryResultName}"
}

artifacts {
    archives file: packageBuildResults.outputs.getFiles().getSingleFile(), builtBy: packageBuildResults
}
